1 介绍
    示例下载 https://github.com/goinaction/code
1.1
1.1.2
    channel在goroutine之间同步消息
    1.goroutine
        goroutine并行函数
        go在运行时会自动在配置的一组逻辑处理器上调度执行goroutine
        每个逻辑处理器绑定到一个系统线程上
    2.channel
        通道channal提供一种新模式保证并发数据安全(保证同一时刻只会有一个goroutine修改数据)
        若传输数据，每个goroutine都修改自己的副本，是安全的，若传输指针，且读写由不同的goroutine完成依旧需要同步
1.1.3 类型
    无继承，使用组合
    独特的接口实现机制，允许用户对行为建模，不需要声明某个类型实现了某个接口，编译器会判断
    1.
        构建小类型，组合成大类型
    2.
        接口用于描述类型的行为，鸭子类型
        最常用的接口之一是io.Reader，声明有数据可以读取
1.2
    playground分享代码http://play.golang.org
1.3
    go使用接口作为代码复用的基础模块

2 快速开始
2.1 程序架构
2.2 main包
    可执行的go程序有2个明显的特征
        main函数，构建程序构建可执行文件时，需要找到这个
        包名main
    导入路径前有下划线，对包做初始化操作，但不使用包里的标识符，GO编译器不允许导入包却不用，下划线可导入，且调用包内所有代码文件里定义的init函数
    程序中每个代码文件里的init都会在main前调用
2.3 search包
2.3.1
    go中导入一个包时，可以直接访问包中公开的标识符，这些标识符以大写字母开关，小写字母开关的标识符是不公开的，可以间接访问
    go中所有变量都被初始化为零值
    := 声明与赋值，声明初始值为零值时使用var，非零或函数返回使用:=
    使用sync包的WaitGroup跟踪所有启动的goroutine

3 打包和工具链
3.1 包
    同一个目录下所有.go文件必须声明为同一个包
3.1.1
    包名使用简洁，清晰且全小写的名字
3.1.2
    访问http://golang.org/pkg/fmt/或者在终端输入godoc fmt来了解更多fmt的细节
3.2
3.2.1
    远程导入使用go get命令完成
3.2.2
    在import关键字后插入导入重命名可以解决冲突
3.3
3.4
3.5
3.6
3.7
3.8
    可以为每个工程设置不同的GOPATH，以保持源代码和依赖隔离
    Go语言设计时考虑了分享代码
    推荐使用依赖管理工具

4
4.1 数组
4.1.1
    数组长度固定
4.1.5
    大数组在函数间的传递，优先考虑切片
4.2 切片
    方便使用及管理数据集合，切片是围绕动态数组的概念构建的，可以按需自动增长和缩小，底层内存连续
4.2.1
    内部3个字段，数组指针、长度、容量
4.2.2
    创建切片_make       slice := make([]string, 5)
    创建切片_字面量     slice := []string{"red", "blue"}
    创建切片_指定长度   slice := []string{99: ""}
    想表示空集合时空切片很有用，例如，数据库查询返回 0 个查询结果时
4.2.3
    切片上切片，可能会共享地址
    append函数会增加切片长度，容量够用时，容量不变，不够时，创建新数组，容量*2
    容量小于1000时，*200%，大于1000时，*125%
    创建切片时第3个索引，可以限制切片容量，保护低层数据
    切片的容量和长度相同，可以强制让新切片的第一个append操作创建新的底层数组，与原有的底层数组分离。
    range 创建了每个元素的副本，而不是直接返回对该元素的引用
    函数len()返回长度，cap()返回容量
4.2.4
4.2.5
4.3 映射
4.3.1
    底层由散列表实现
4.3.2
    dict := make(map[string]int)
    dict := map[string]string{"red": "#da1337", "orange": "#e95a22"}
    键可以是任何值，必须支持==操作，切片，函数，及包含切片的struct等，由于具有引用语义，不能作键
4.3.3
    声明初始化      空映射  colors := map[string]string{}   可以添加元素
    声明未初始化    nil映射 var nilMap map[string]string    不能添加元素
    取值            value, exists := colors["Blue"]       if exists {...}
    键不存在时，返回零值
    range返回键值对，无索引
    delete()删除键
4.3.4
    函数间传递映射时，传递引用，修改会影响调用方
4.4
    cap()只能用于切片

5 类型系统
    有些类型的内部表示与代码的机器的体系结构有关。如一个int可能是8字节，也有可能是4字节
5.1 用户定义类型
    type xxx struct{}
    type Duration int64
5.2 方法
    可以给用户定义类型添加新行为，方法也是函数，声明时，在 func 和方法名之间增加了一个参数
    值接收者    func (u user) notify() {                        使用u的副本调用
    指针接收者  func (u *user) changeEmail(email string) {      使用u调用
5.3 类型的本质
    声明类型的方法之前，增加或者删除某个值，是要创建一个新值，还是要更改当前的值
        增加或删除  值接收者
        修改        指针接收者
5.3.1
    原始类型使用值传递
5.3.2
    声明引用类型的变量时，创建的变量称为标头(header)，包含一个指针，还包含一组独特的字段用于管理底层数据结构
    编译器只允许为命名的用户定义类型声明方法
5.3.3
    大多数情况下，结构类型是非原始的，增加删除操作应该更改值本身
5.4
5.4.1
5.4.2
    用户定义类型的值，赋给接口类型的值
5.4.3
    方法集定义了接口的接受规则，方法集定义了一组关联到给定类型的值或者指针的方法
    Values          Methods Receivers
    T               (t T)
    *T              (t T) and (t *T)
    Methods Receivers       Values
    (t T)                   T and *T
    (t *T)                  *T                  因为编译器不总是能自动获得一个值的地址
5.4.4
    多态函数
5.5
    嵌入类型
    如果外部类型实现了 notify 方法，内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。
5.6

6 并发
    调度器在任何给定的时间，都会全面控制哪个goroutine要在哪个逻辑处理器上运行
6.1
    可以将进程看作一个包含了应用程序在运行中需要用到和维护的各种资源的容器
    一个线程是一个执行空间，这个空间会被操作系统调度来运行函数中所写的代码
    Go语言每个逻辑处理器都分别绑定到单个操作系统线程
    在 1.5 版本上，Go语言的运行时默认会为每个可用的物理处理器分配一个逻辑处理器
    调度器对可以创建的逻辑处理器的数量没有限制，但语言运行时默认限制每个程序最多创建 10 000 个线程。这个限制值可以通过调用 runtime/debug 包的 SetMaxThreads 方法来更改
6.2
    runtime.GOMAXPROCS(1) // 分配一个逻辑处理器给调度器使用
    需要强调的是，使用多个逻辑处理器并不意味着性能更好
6.3
    竞争状态（race candition）
    对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个 goroutine 对共享资源进行读和写操作
6.4
6.4.1
    当 goroutine 试图去调用任何原子函数时，这些 goroutine 都会自动根据所引用的变量做同步处理
    goroutine 试图在 main 函数调用 StoreInt64 的同时调用 LoadInt64 函数，那么原子函数会将这些调用互相同步，保证这些操作都是安全的，不会进入竞争状态
6.4.2
    互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界区代码
6.5
6.5.1
6.5.2
    当通道关闭后，goroutine 依旧可以从通道接收数据，但是不能再向通道里发送数据

7 并发模式
7.1 runner
    runner 包用于展示如何使用通道来监视程序的执行时间，如果程序运行时间太长，也可以用 runner 包来终止程序
7.2 pool
7.3 work

8 标准库
8.1
    https://golang.org/pkg/ 包描述
    源代码预编译后的文件，称作归档文件（archive file），可以 在$GOROOT/pkg 文件夹中找到
    日志是开发人员的眼睛和耳朵
8.2
8.2.1
    iota 关键字让编译器为每个常量复制相同的表达式，直到声明区结束，或者遇到一个新的赋值语句。
    关键字 iota 的另一个功能是，iota 的初始值为 0，之后 iota 的值在每次处理为常量后，都会自增 1
8.2.2 定制日志记录器
8.2.3 结论
8.3
8.3.1
8.3.2
8.3.3
8.4
8.4.1
8.4.2
8.4.3

9 测试与性能
9.1
    正向路经测试
    负向路经测试
    basic test
    table test
    mock
9.1.1 基顾测试
    命令go test -v，处理以_test.go结尾的文件
    一个测试函数必须是公开的函数，并且以 Test 单词开头
    函数的签名必须接收一个指向 testing.T 类型的指针，并且不返回任何值
9.1.2 表组测试
9.1.3 mock
    包 httptest 可以让你能够模仿互联网资源的请求和响应
9.1.4 endpoint
    包名以_test结尾时，测试代码只能访问包里公开的标识符
9.2
    godoc 生成示例
9.3 基准测试
    文件以_test.go结尾
    函数以 Benchmark 开头，接受一个指向 testing.B 类型的指针作为唯一参数
    go test -v -run="none" -bench="BenchmarkSprintf"